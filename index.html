<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>RiftPDB</title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
    <link rel="stylesheet/less" href="css/index.less" />

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.2.26/angular.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r69/three.js"></script>
    <script src="js/VRControls.js"></script>
    <script src="js/VREffect.js"></script>
    <script src="js/PDBLoader.js"></script>
    <script src="js/CSS2DRenderer.js"></script>
    <script src="less/less-1.3.3.min.js"></script>

</head>


<body>

        <canvas id="viewer"></canvas>

</body>

<script>

    //
    // CREATE THE SCENE
    //
    //
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      10000
    );
    var canvas = document.getElementById('scene');
    canvas.style.position = 'absolute';
    canvas.style.top = 0;
    canvas.style.left = 0;
    var renderer = new THREE.WebGLRenderer({
        antialias: true,
        canvas: canvas
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    onResize = function () {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', onResize, false);
    var light = new THREE.PointLight(0xffffff, 1, 1000);
    scene.add(light);
    axisHelper = new THREE.AxisHelper(0.060);
    axisHelper.position.set(0, -0.03, -0.30);
    scene.add(axisHelper);
    //
    // ADD CUBES (blah blah)
    //
    //
    var cubeGeo = new THREE.BoxGeometry(0.032, 0.032, 0.032);
    var cubeMesh = new THREE.MeshPhongMaterial({ color: 0x00cc00 });
    // forwards
    var cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(-0.06, -0.03, -0.3);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(0.06, -0.03, -0.3);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(-0.06, -0.03, -0.42);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(0.06, -0.03, -0.42);
    scene.add(cube);
    // right
    cubeMesh = new THREE.MeshPhongMaterial({ color: 0x0000cc });
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(0.3, -0.03, -0.06);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(0.3, -0.03, 0.06);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(0.42, -0.03, -0.06);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(0.42, -0.03, 0.06);
    scene.add(cube);
    // left
    cubeMesh = new THREE.MeshPhongMaterial({ color: 0xcc0000 });
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(-0.3, -0.03, -0.06);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(-0.3, -0.03, 0.06);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(-0.42, -0.03, -0.06);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(-0.42, -0.03, 0.06);
    scene.add(cube);
    // back
    cubeMesh = new THREE.MeshPhongMaterial({ color: 0xcccc00 });
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(-0.06, -0.03, 0.3);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(0.06, -0.03, 0.3);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(-0.06, -0.03, 0.42);
    scene.add(cube);
    cube = new THREE.Mesh(cubeGeo, cubeMesh);
    cube.position.set(0.06, -0.03, 0.42);
    scene.add(cube);
    //
    // ADD VIRTUAL REALITY
    //
    //
    // Moves (translates and rotates) the camera
    var vrControls = new THREE.VRControls(camera);
    var vrEffect = new THREE.VREffect(renderer);
    var onkey = function (event) {
        if (event.key === 'z') {
            vrControls.zeroSensor();
        }
        if (event.key === 'f') {
            return vrEffect.setFullScreen(true);
        }
    };
    window.addEventListener("keypress", onkey, true);
    //
    // MAKE IT GO
    //
    //
    var render = function () {
        vrControls.update();
        vrEffect.render(scene, camera);
        requestAnimationFrame(render);
    };

    render();

    //
    // Add a debug message Real quick
    // Prints out when receiving oculus data.
    //
    //
    var receivingPositionalData = false;
    var receivingOrientationData = false;
    var timerID = setInterval(function () {
        if (camera.position.x !== 0 && !receivingPositionalData) {
            receivingPositionalData = true;
            console.log("receiving positional data");
        }
        if (camera.quaternion.x !== 0 && !receivingOrientationData) {
            receivingOrientationData = true;
            console.log("receiving orientation data");
        }
        if (receivingOrientationData && receivingPositionalData) {
            clearInterval(timerID);
        }
    }, 2000);

</script>


</html>